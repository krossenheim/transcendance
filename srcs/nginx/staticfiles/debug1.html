<!DOCTYPE html>
<html lang="en">
  <meta charset="utf-8" />
  <title>Pong Balls Viewer</title>
  <label for="boardId">Board ID:</label>
  <input type="number" id="boardId" min="1" value="1" />
  <p>Press "W" to move up/left and "S" to move down/right.</p>
  <canvas id="c" width="1000" height="1000" style="background: #000"></canvas>

  <script type="module">
    import ws from "/static/websocket.js";
    const ctx = document.getElementById("c").getContext("2d");
    const canvas = document.getElementById("c");

    const backendWidth = 1000;
    const backendHeight = 1000;

    let balls = [];
    let paddles = [];

    // map backend coordinates to canvas
    function mapToCanvas(x, y) {
      const scaleX = canvas.width / backendWidth;
      const scaleY = canvas.height / backendHeight;
      return { cx: x * scaleX, cy: y * scaleY };
    }
    function mapToCanvas2(x, y, r) {
      const scaleX = canvas.width / backendWidth;
      const scaleY = canvas.height / backendHeight;
      const cx = (x + r) * scaleX;
      const cy = canvas.height - (y + r) * scaleY;
      return { cx, cy };
    }
    ws.onmessage = (e) => {
      try {
        const data = JSON.parse(e.data);

        if (data && Array.isArray(data.balls)) balls = data.balls;
        if (data && Array.isArray(data.paddles)) paddles = data.paddles;
      } catch (err) {
        console.error(err);
      }
    };

    // Keep track of previous velocities for balls
    // Track previous velocities
    const prevBallVel = new Map();
    // Store persistent velocity-change dots
    const velChangeDots = [];
    const trails = new Map();
    const TRAIL_LENGTH = 3; // store last 3 positions
    const TRAIL_LIFETIME = 100; // store last 3 positions

    function draw() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw balls
      balls.forEach((b) => {
        const { cx, cy } = mapToCanvas(b.x, b.y, b.r);
        const scaleX = canvas.width / backendWidth;
        const scaleY = canvas.height / backendHeight;

        // Ball circle
        ctx.beginPath();
        ctx.arc(cx, cy, b.r * Math.min(scaleX, scaleY), 0, Math.PI * 2);
        ctx.fillStyle = "yellow";
        ctx.fill();
        // --- Update trail ---
        if (!trails.has(b.id)) trails.set(b.id, []);
        const stack = trails.get(b.id);

        // Push current position
        // Push current position with age 0
        stack.push({ x: b.x, y: b.y, age: 0 });

        // Draw trail dots and increment age
        for (let i = stack.length - 1; i >= 0; i--) {
          const dot = stack[i];
          dot.age++;
          if (dot.age > TRAIL_LIFETIME) {
            stack.splice(i, 1); // remove old dot
            continue;
          }
          const { cx: ox, cy: oy } = mapToCanvas(dot.x, dot.y);
          ctx.beginPath();
          ctx.arc(ox, oy, b.r * 0.5 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
          // Optional: fade color by age
          const alpha = 1 - dot.age / TRAIL_LIFETIME;
          ctx.fillStyle = `rgba(255,0,255,${alpha})`;
          ctx.fill();
        }
        // Check for velocity change
        const key = b.id;
        const prev = prevBallVel.get(key);
        if (prev) {
          const prevVel = { x: prev.dx, y: prev.dy };
          const currVel = { x: b.dx, y: b.dy };

          const dot = prevVel.x * currVel.x + prevVel.y * currVel.y;

          if (dot < 0) {
            // Significant reversal, record dot
            velChangeDots.push({ x: b.x, y: b.y, r: b.r });
          }
        }
        prevBallVel.set(key, { dx: b.dx, dy: b.dy });
      });

      // Draw persistent orange velocity-change dots
      velChangeDots.forEach((dot) => {
        const { cx, cy } = mapToCanvas(dot.x, dot.y);
        const scaleX = canvas.width / backendWidth;
        const scaleY = canvas.height / backendHeight;
        ctx.beginPath();
        ctx.arc(cx, cy, dot.r * 0.5 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
        ctx.fillStyle = "orange";
        ctx.fill();
      });

      // Draw paddles
      paddles.forEach((p) => {
        const P = { x: p.a1, y: p.a2 };
        const Q = { x: p.b1, y: p.b2 };

        const dir = { x: Q.x - P.x, y: Q.y - P.y };
        const length = Math.hypot(dir.x, dir.y);
        const unitDir = { x: dir.x / length, y: dir.y / length };

        const perp = { x: -unitDir.y, y: unitDir.x };
        const halfW = (p.w || 10) / 2;

        const corners = [
          { x: P.x + perp.x * halfW, y: P.y + perp.y * halfW },
          { x: Q.x + perp.x * halfW, y: Q.y + perp.y * halfW },
          { x: Q.x - perp.x * halfW, y: Q.y - perp.y * halfW },
          { x: P.x - perp.x * halfW, y: P.y - perp.y * halfW },
        ];

        // Paddle rectangle
        ctx.fillStyle = "blue";
        ctx.beginPath();
        corners.forEach((c, i) => {
          const { cx, cy } = mapToCanvas(c.x, c.y);
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        });
        ctx.closePath();
        ctx.fill();

        // Paddle center dot (green)
        const center = { x: (P.x + Q.x) / 2, y: (P.y + Q.y) / 2 };
        const { cx: ccx, cy: ccy } = mapToCanvas(center.x, center.y);
        ctx.beginPath();
        ctx.arc(ccx, ccy, 5, 0, Math.PI * 2);
        ctx.fillStyle = "green";
        ctx.fill();

        // Red line connecting P and Q
        const { cx: cx1, cy: cy1 } = mapToCanvas(P.x, P.y);
        const { cx: cx2, cy: cy2 } = mapToCanvas(Q.x, Q.y);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx1, cy1);
        ctx.lineTo(cx2, cy2);
        ctx.stroke();
      });

      requestAnimationFrame(draw);
    }

    draw();

    // Track key states
    const keyState = { w: false, s: false };

    function handleKeyChange(boardId, key, pressed) {
      const prevState = keyState[key];
      keyState[key] = pressed;

      if (prevState !== pressed) {
        let move = null;
        if (key === "w") move = pressed ? true : null;
        if (key === "s") move = pressed ? false : null;

        const payload = {
          endpoint: "/api/pong/move_paddle",
          b: boardId,
          m: move,
        };
        runMovePaddle(payload);
      }
    }

    function runMovePaddle(payload) {
      console.log("Paddle move:", payload);
      ws.send(JSON.stringify(payload));
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "w" || e.key === "s") {
        const boardId = parseInt(document.getElementById("boardId").value, 10);
        handleKeyChange(boardId, e.key, true);
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.key === "w" || e.key === "s") {
        const boardId = parseInt(document.getElementById("boardId").value, 10);
        handleKeyChange(boardId, e.key, false);
      }
    });
  </script>
</html>
