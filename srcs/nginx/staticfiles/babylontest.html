<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Babylon.js Pong Game</title>
<style>
  html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
  #renderCanvas { width: 100%; height: 100%; touch-action: none; }
  #ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-family: Arial, sans-serif; font-size: 24px; z-index: 100; }
  #controls { position: absolute; bottom: 20px; left: 20px; color: white; font-family: Arial, sans-serif; font-size: 14px; z-index: 100; }
</style>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="ui">
  <div>Player 1: <span id="leftScore">0</span> | Player 2: <span id="rightScore">0</span></div>
</div>
<div id="controls">
  <div>Player 1: W/S keys | Player 2: ↑/↓ keys</div>
</div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// ===== Game State =====
const gameState = {
  ballSpeed: 0.15,
  paddleSpeed: 0.25,
  leftScore: 0,
  rightScore: 0,
  ballDirection: { x: 1, y: 0.5 },
  keys: {}
};

// Background
const backgroundPlane = BABYLON.MeshBuilder.CreatePlane("backgroundPlane", { width: 40, height: 25 }, scene);
backgroundPlane.position.z = 8;
const backgroundMaterial = new BABYLON.StandardMaterial("backgroundMaterial", scene);
backgroundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.5);
backgroundPlane.material = backgroundMaterial;

// ===== Camera =====
const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, -15), scene);
camera.setTarget(new BABYLON.Vector3(0, 0, 0));

// ===== Lighting with Shadows =====
const directionalLight = new BABYLON.DirectionalLight("directionalLight", new BABYLON.Vector3(0, -0.5, 1), scene);
directionalLight.position = new BABYLON.Vector3(0, 6, -20);
directionalLight.intensity = 2.2;

const shadowGenerator = new BABYLON.ShadowGenerator(2048, directionalLight);
shadowGenerator.useExponentialShadowMap = true;
shadowGenerator.useKernelBlur = true;
shadowGenerator.blurKernel = 64;
shadowGenerator.bias = 0.0005;

// ===== Game Objects =====
const leftPaddle = BABYLON.MeshBuilder.CreateBox("leftPaddle", { width: 0.3, height: 3, depth: 0.3 }, scene);
leftPaddle.position.x = -10;
const rightPaddle = BABYLON.MeshBuilder.CreateBox("rightPaddle", { width: 0.3, height: 3, depth: 0.3 }, scene);
rightPaddle.position.x = 10;

const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 0.4 }, scene);
ball.position.set(0, 0, 0);

const topWall = BABYLON.MeshBuilder.CreateBox("topWall", { width: 25, height: 0.3, depth: 0.3 }, scene);
topWall.position.y = 6;
const bottomWall = BABYLON.MeshBuilder.CreateBox("bottomWall", { width: 25, height: 0.3, depth: 0.3 }, scene);
bottomWall.position.y = -6;

const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 18 }, scene);
ground.position.z = 3;

const backWall = BABYLON.MeshBuilder.CreatePlane("backWall", { width: 30, height: 18 }, scene);
backWall.position.z = 5;

// ===== Materials =====
const paddleMaterial = new BABYLON.StandardMaterial("paddleMaterial", scene);
paddleMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
leftPaddle.material = paddleMaterial;
rightPaddle.material = paddleMaterial;

const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
ballMaterial.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
ball.material = ballMaterial;

const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", scene);
wallMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.8);
topWall.material = wallMaterial;
bottomWall.material = wallMaterial;

const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
groundMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
groundMaterial.alpha = 1.0;
ground.material = groundMaterial;

const backWallMaterial = new BABYLON.StandardMaterial("backWallMaterial", scene);
backWallMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
backWallMaterial.alpha = 1.0;
backWall.material = backWallMaterial;

// Shadows
shadowGenerator.addShadowCaster(leftPaddle);
shadowGenerator.addShadowCaster(rightPaddle);
shadowGenerator.addShadowCaster(ball);
ground.receiveShadows = true;
backWall.receiveShadows = true;

// ===== Input Handling =====
window.addEventListener("keydown", (e) => { gameState.keys[e.code] = true; });
window.addEventListener("keyup", (e) => { gameState.keys[e.code] = false; });

// ===== Game Functions =====
function updatePaddles() {
  if (gameState.keys["KeyW"] && leftPaddle.position.y < 4.5) leftPaddle.position.y += gameState.paddleSpeed;
  if (gameState.keys["KeyS"] && leftPaddle.position.y > -4.5) leftPaddle.position.y -= gameState.paddleSpeed;
  if (gameState.keys["ArrowUp"] && rightPaddle.position.y < 4.5) rightPaddle.position.y += gameState.paddleSpeed;
  if (gameState.keys["ArrowDown"] && rightPaddle.position.y > -4.5) rightPaddle.position.y -= gameState.paddleSpeed;
}

function updateBall() {
  ball.position.x += gameState.ballDirection.x * gameState.ballSpeed;
  ball.position.y += gameState.ballDirection.y * gameState.ballSpeed;

  if (ball.position.y > 5.7 || ball.position.y < -5.7) gameState.ballDirection.y *= -1;

  if (ball.position.x < -9.5 && ball.position.x > -10.5 &&
      ball.position.y < leftPaddle.position.y + 1.5 &&
      ball.position.y > leftPaddle.position.y - 1.5) {
    gameState.ballDirection.x = Math.abs(gameState.ballDirection.x);
    gameState.ballDirection.y += (ball.position.y - leftPaddle.position.y) * 0.3;
  }

  if (ball.position.x > 9.5 && ball.position.x < 10.5 &&
      ball.position.y < rightPaddle.position.y + 1.5 &&
      ball.position.y > rightPaddle.position.y - 1.5) {
    gameState.ballDirection.x = -Math.abs(gameState.ballDirection.x);
    gameState.ballDirection.y += (ball.position.y - rightPaddle.position.y) * 0.3;
  }

  if (ball.position.x > 12) { gameState.leftScore++; updateScore(); resetBall(); }
  else if (ball.position.x < -12) { gameState.rightScore++; updateScore(); resetBall(); }
}

function resetBall() {
  ball.position.set(0, 0, 0);
  gameState.ballDirection.x = Math.random() > 0.5 ? 1 : -1;
  gameState.ballDirection.y = (Math.random() - 0.5) * 0.8;
}

function updateScore() {
  document.getElementById("leftScore").textContent = gameState.leftScore;
  document.getElementById("rightScore").textContent = gameState.rightScore;
}

// ===== Animate Sun (Light) =====
scene.onBeforeRenderObservable.add(() => {
  const time = performance.now() * 0.00005; // smaller = slower cycle
  const radius = 30;

  const sunX = Math.sin(time) * radius;
  const sunY = Math.cos(time) * radius * 0.5 + 10; // stays above horizon
  const sunZ = -20;

  directionalLight.position.set(sunX, sunY, sunZ);
  directionalLight.direction = new BABYLON.Vector3(-sunX, -sunY, 20).normalize();

  // Color shift (warm at sunrise/sunset, white at noon)
  const t = (Math.cos(time) + 1) / 2; // oscillates 0–1
  directionalLight.diffuse = new BABYLON.Color3(1.0, 0.6 + 0.4 * t, 0.4 + 0.6 * t);
});

// ===== Render loop =====
engine.runRenderLoop(() => {
  updatePaddles();
  updateBall();
  scene.render();
});

// Resize
window.addEventListener("resize", () => { engine.resize(); });

// Init
resetBall();
updateScore();
</script>
</body>
</html>
