<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Babylon.js Pong Game</title>
<style>
  html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
  #renderCanvas { width: 100%; height: 100%; touch-action: none; }
  #ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-family: Arial, sans-serif; font-size: 24px; z-index: 100; }
  #controls { position: absolute; bottom: 20px; left: 20px; color: white; font-family: Arial, sans-serif; font-size: 14px; z-index: 100; }
</style>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="ui">
  <div>Player 1: <span id="leftScore">0</span> | Player 2: <span id="rightScore">0</span></div>
</div>
<div id="controls">
  <div>Player 1: W/S keys | Player 2: ↑/↓ keys</div>
</div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// ===== Game State =====
const gameState = {
  ballSpeed: 0.15,
  baseBallSpeed: 0.15,
  speedMultiplier: 1.0,
  maxSpeedMultiplier: 2.5,
  paddleSpeed: 0.25,
  leftScore: 0,
  rightScore: 0,
  ballDirection: { x: 1, y: 0.5 },
  keys: {},
  ballAnimationState: 'normal',
  ballAnimationTimer: 0,
  squashDuration: 0.15,
  stretchDuration: 0.1,
  squashAxis: "y",
  // Camera shake
  cameraShakeTime: 0,
  cameraShakeDuration: 0.1,
  cameraShakeIntensity: 0
};

// ===== Video Background =====
const backgroundPlane = BABYLON.MeshBuilder.CreatePlane("backgroundPlane", { width: 40, height: 25 }, scene);
backgroundPlane.position.z = 8;

const videoTexture = new BABYLON.VideoTexture("videoTexture", ["https://localhost/static/catground.mp4"], scene, true, true);
videoTexture.video.loop = true;
videoTexture.video.muted = true;
videoTexture.video.autoplay = true;
videoTexture.video.play().catch(e => console.log('Video play failed:', e));

const backgroundMaterial = new BABYLON.StandardMaterial("backgroundMaterial", scene);
backgroundMaterial.diffuseTexture = videoTexture;
backgroundMaterial.disableLighting = true;
backgroundMaterial.emissiveTexture = videoTexture;
backgroundMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
backgroundPlane.material = backgroundMaterial;

// ===== Camera =====
const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, -15), scene);
camera.setTarget(new BABYLON.Vector3(0, 0, 0));

// ===== Lighting =====
const directionalLight = new BABYLON.DirectionalLight("directionalLight", new BABYLON.Vector3(0, -0.5, 1), scene);
directionalLight.position = new BABYLON.Vector3(0, 6, -20);
directionalLight.intensity = 2.2;

const shadowGenerator = new BABYLON.ShadowGenerator(2048, directionalLight);
shadowGenerator.useExponentialShadowMap = true;
shadowGenerator.useKernelBlur = true;
shadowGenerator.blurKernel = 64;
shadowGenerator.bias = 0.0005;

const ballLight = new BABYLON.PointLight("ballLight", new BABYLON.Vector3(0, 0, 0), scene);
ballLight.diffuse = new BABYLON.Color3(0.2, 0.6, 1.0);
ballLight.specular = new BABYLON.Color3(0.4, 0.8, 1.0);
ballLight.intensity = 3.0;
ballLight.range = 8.0;
ballLight.falloffType = BABYLON.Light.FALLOFF_GLTF;

// ===== Game Objects =====
const leftPaddle = BABYLON.MeshBuilder.CreateBox("leftPaddle", { width: 0.3, height: 3, depth: 0.3 }, scene);
leftPaddle.position.x = -10;
const rightPaddle = BABYLON.MeshBuilder.CreateBox("rightPaddle", { width: 0.3, height: 3, depth: 0.3 }, scene);
rightPaddle.position.x = 10;

const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 0.4 }, scene);
ball.position.set(0, 0, 0);

const topWall = BABYLON.MeshBuilder.CreateBox("topWall", { width: 25, height: 0.3, depth: 0.3 }, scene);
topWall.position.y = 6;
const bottomWall = BABYLON.MeshBuilder.CreateBox("bottomWall", { width: 25, height: 0.3, depth: 0.3 }, scene);
bottomWall.position.y = -6;

const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 18 }, scene);
ground.position.z = 3;
ground.visibility = 0.3;

const backWall = BABYLON.MeshBuilder.CreatePlane("backWall", { width: 30, height: 18 }, scene);
backWall.position.z = 5;
backWall.visibility = 0.2;

// ===== Materials =====
const paddleMaterial = new BABYLON.StandardMaterial("paddleMaterial", scene);
paddleMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
leftPaddle.material = paddleMaterial;
rightPaddle.material = paddleMaterial;

const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
ballMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.9, 1);
ballMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.6, 1);
ball.material = ballMaterial;

const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", scene);
wallMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.8);
topWall.material = wallMaterial;
bottomWall.material = wallMaterial;

ground.material = new BABYLON.StandardMaterial("groundMaterial", scene);
backWall.material = new BABYLON.StandardMaterial("backWallMaterial", scene);

shadowGenerator.addShadowCaster(leftPaddle);
shadowGenerator.addShadowCaster(rightPaddle);
shadowGenerator.addShadowCaster(ball);
ground.receiveShadows = true;
backWall.receiveShadows = true;

// ===== Input Handling =====
window.addEventListener("keydown", (e) => { gameState.keys[e.code] = true; });
window.addEventListener("keyup", (e) => { gameState.keys[e.code] = false; });

// ===== Functions =====
function updatePaddles() {
  if (gameState.keys["KeyW"] && leftPaddle.position.y < 4.5) leftPaddle.position.y += gameState.paddleSpeed;
  if (gameState.keys["KeyS"] && leftPaddle.position.y > -4.5) leftPaddle.position.y -= gameState.paddleSpeed;
  if (gameState.keys["ArrowUp"] && rightPaddle.position.y < 4.5) rightPaddle.position.y += gameState.paddleSpeed;
  if (gameState.keys["ArrowDown"] && rightPaddle.position.y > -4.5) rightPaddle.position.y -= gameState.paddleSpeed;
}

function updateBall() {
  ball.position.x += gameState.ballDirection.x * gameState.ballSpeed;
  ball.position.y += gameState.ballDirection.y * gameState.ballSpeed;

  // Wall collisions
  if (ball.position.y > 5.7 || ball.position.y < -5.7) {
    gameState.ballDirection.y *= -1;
    ball.position.y = ball.position.y > 0 ? 5.7 : -5.7; // Push ball back to boundary
    triggerBallSquash("y", 0.08);
  }

  // Left paddle - only check if ball is moving LEFT towards paddle
  if (gameState.ballDirection.x < 0 && 
      ball.position.x < -9.5 && ball.position.x > -10.5 &&
      ball.position.y < leftPaddle.position.y + 1.5 &&
      ball.position.y > leftPaddle.position.y - 1.5) {
    gameState.ballDirection.x = Math.abs(gameState.ballDirection.x);
    gameState.ballDirection.y += (ball.position.y - leftPaddle.position.y) * 0.3;
    ball.position.x = -9.5; // Push ball back to paddle surface
    increaseSpeed();
    triggerBallSquash("x", 0.15);
  }

  // Right paddle - only check if ball is moving RIGHT towards paddle  
  if (gameState.ballDirection.x > 0 &&
      ball.position.x > 9.5 && ball.position.x < 10.5 &&
      ball.position.y < rightPaddle.position.y + 1.5 &&
      ball.position.y > rightPaddle.position.y - 1.5) {
    gameState.ballDirection.x = -Math.abs(gameState.ballDirection.x);
    gameState.ballDirection.y += (ball.position.y - rightPaddle.position.y) * 0.3;
    ball.position.x = 9.5; // Push ball back to paddle surface
    increaseSpeed();
    triggerBallSquash("x", 0.15);
  }

  if (ball.position.x > 12) { gameState.leftScore++; updateScore(); resetBall(); }
  else if (ball.position.x < -12) { gameState.rightScore++; updateScore(); resetBall(); }
}

function increaseSpeed() {
  if (gameState.speedMultiplier < gameState.maxSpeedMultiplier) {
    gameState.speedMultiplier += 0.1;
    gameState.ballSpeed = gameState.baseBallSpeed * gameState.speedMultiplier;
  }
}

function resetBall() {
  ball.position.set(0, 0, 0);
  gameState.ballDirection.x = Math.random() > 0.5 ? 1 : -1;
  gameState.ballDirection.y = (Math.random() - 0.5) * 0.8;
  gameState.speedMultiplier = 1.0;
  gameState.ballSpeed = gameState.baseBallSpeed;
  gameState.ballAnimationState = 'normal';
  ball.scaling.set(1, 1, 1);
}

function updateScore() {
  document.getElementById("leftScore").textContent = gameState.leftScore;
  document.getElementById("rightScore").textContent = gameState.rightScore;
}

function triggerBallSquash(axis, shakeStrength) {
  gameState.ballAnimationState = 'squashing';
  gameState.ballAnimationTimer = 0;
  gameState.squashAxis = axis;
  gameState.cameraShakeTime = gameState.cameraShakeDuration;
  gameState.cameraShakeIntensity = shakeStrength;
}

function updateBallAnimation(deltaTime) {
  switch (gameState.ballAnimationState) {
    case 'squashing':
      gameState.ballAnimationTimer += deltaTime;

      const squashAmount = 0.5;
      const expandAmount = 1.5;

      if (gameState.squashAxis === "x") {
        ball.scaling.x = 1 - squashAmount;
        ball.scaling.y = expandAmount;
        ball.scaling.z = expandAmount;
      } else {
        ball.scaling.y = 1 - squashAmount;
        ball.scaling.x = expandAmount;
        ball.scaling.z = expandAmount;
      }

      if (gameState.ballAnimationTimer >= gameState.squashDuration) {
        gameState.ballAnimationState = 'stretching';
        gameState.ballAnimationTimer = 0;
      }
      break;

    case 'stretching':
      gameState.ballAnimationTimer += deltaTime;

      const maxStretch = 1.4;
      const minWidth = 0.8;

      if (gameState.squashAxis === "x") {
        ball.scaling.x = maxStretch;
        ball.scaling.y = minWidth;
        ball.scaling.z = minWidth;
      } else {
        ball.scaling.y = maxStretch;
        ball.scaling.x = minWidth;
        ball.scaling.z = minWidth;
      }

      if (gameState.ballAnimationTimer >= gameState.stretchDuration) {
        gameState.ballAnimationState = 'normal';
        ball.scaling.set(1, 1, 1);
      }
      break;

    case 'normal':
      ball.scaling.set(1, 1, 1);
      break;
  }
}

// ===== Render loop =====
let lastTime = performance.now();
engine.runRenderLoop(() => {
  const currentTime = performance.now();
  const deltaTime = (currentTime - lastTime) / 1000;
  lastTime = currentTime;

  updatePaddles();
  updateBall();
  updateBallAnimation(deltaTime);

  // Camera shake (with rotation)
  if (gameState.cameraShakeTime > 0) {
    gameState.cameraShakeTime -= deltaTime;

    const progress = gameState.cameraShakeTime / gameState.cameraShakeDuration;
    const intensity = gameState.cameraShakeIntensity * progress;

    // Jitter position
    const offsetX = (Math.random() - 0.5) * intensity;
    const offsetY = (Math.random() - 0.5) * intensity;

    // Add a tiny tilt (rotation around Z)
    const tilt = (Math.random() - 0.5) * intensity * 0.5;

    camera.position.x = offsetX;
    camera.position.y = offsetY;
    camera.rotation.z = tilt;
  } else {
    // Smoothly return to neutral
    camera.position.x *= 0.85;
    camera.position.y *= 0.85;
    camera.rotation.z *= 0.85;
  }

  // Update ball light position
  ballLight.position.copyFrom(ball.position);

  scene.render();
});

// ===== Cleanup =====
window.addEventListener("beforeunload", () => {
  engine.dispose();
});
</script>
</body>
</html>