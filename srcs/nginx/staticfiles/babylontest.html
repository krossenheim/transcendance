<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Babylon.js Pong Game</title>
<style>
  html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
  #renderCanvas { width: 100%; height: 100%; touch-action: none; }
  #ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-family: Arial, sans-serif; font-size: 24px; z-index: 100; }
  #controls { position: absolute; bottom: 20px; left: 20px; color: white; font-family: Arial, sans-serif; font-size: 14px; z-index: 100; }
</style>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="ui">
  <div>Player 1: <span id="leftScore">0</span> | Player 2: <span id="rightScore">0</span></div>
</div>
<div id="controls">
  <div>Player 1: W/S keys | Player 2: ↑/↓ keys</div>
</div>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// ===== Game State =====
const gameState = {
  ballSpeed: 0.15,
  paddleSpeed: 0.25,
  leftScore: 0,
  rightScore: 0,
  ballDirection: { x: 1, y: 0.5 },
  keys: {},
  trailPositions: []
};

// Video Background
const backgroundPlane = BABYLON.MeshBuilder.CreatePlane("backgroundPlane", { width: 40, height: 25 }, scene);
backgroundPlane.position.z = 8;

// Create video texture from catground.mp4
const videoTexture = new BABYLON.VideoTexture("videoTexture", ["https://localhost/static/catground.mp4"], scene, true, true);

// Video configuration with error handling
videoTexture.video.addEventListener('loadeddata', () => {
  console.log('Video loaded successfully');
});

videoTexture.video.addEventListener('error', (e) => {
  console.error('Video failed to load:', e);
});

videoTexture.video.loop = true;
videoTexture.video.muted = true;
videoTexture.video.autoplay = true;
videoTexture.video.play().catch(e => console.log('Video play failed:', e));

// Use unlit material to avoid lighting conflicts
const backgroundMaterial = new BABYLON.StandardMaterial("backgroundMaterial", scene);
backgroundMaterial.diffuseTexture = videoTexture;
backgroundMaterial.disableLighting = true; // Disable lighting calculations
backgroundMaterial.emissiveTexture = videoTexture; // Make it fully self-illuminated
backgroundMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1); // Full brightness
backgroundPlane.material = backgroundMaterial;

// Ensure background doesn't cast or receive shadows
backgroundPlane.receiveShadows = false;

// ===== Camera =====
const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 0, -15), scene);
camera.setTarget(new BABYLON.Vector3(0, 0, 0));

// ===== Lighting with Shadows =====
const directionalLight = new BABYLON.DirectionalLight("directionalLight", new BABYLON.Vector3(0, -0.5, 1), scene);
directionalLight.position = new BABYLON.Vector3(0, 6, -20);
directionalLight.intensity = 2.2;

const shadowGenerator = new BABYLON.ShadowGenerator(2048, directionalLight);
shadowGenerator.useExponentialShadowMap = true;
shadowGenerator.useKernelBlur = true;
shadowGenerator.blurKernel = 64;
shadowGenerator.bias = 0.0005;

// ===== Game Objects =====
const leftPaddle = BABYLON.MeshBuilder.CreateBox("leftPaddle", { width: 0.3, height: 3, depth: 0.3 }, scene);
leftPaddle.position.x = -10;
const rightPaddle = BABYLON.MeshBuilder.CreateBox("rightPaddle", { width: 0.3, height: 3, depth: 0.3 }, scene);
rightPaddle.position.x = 10;

const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 0.4 }, scene);
ball.position.set(0, 0, 0);

const topWall = BABYLON.MeshBuilder.CreateBox("topWall", { width: 25, height: 0.3, depth: 0.3 }, scene);
topWall.position.y = 6;
const bottomWall = BABYLON.MeshBuilder.CreateBox("bottomWall", { width: 25, height: 0.3, depth: 0.3 }, scene);
bottomWall.position.y = -6;

const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 18 }, scene);
ground.position.z = 3;
ground.visibility = 0.3; // Make ground semi-transparent

const backWall = BABYLON.MeshBuilder.CreatePlane("backWall", { width: 30, height: 18 }, scene);
backWall.position.z = 5;
backWall.visibility = 0.2; // Make back wall semi-transparent

// ===== Fire Particle System =====
const fireParticleSystem = new BABYLON.ParticleSystem("fire", 300, scene);
fireParticleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
fireParticleSystem.emitter = ball;

// Emission properties
fireParticleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1);
fireParticleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);
fireParticleSystem.color1 = new BABYLON.Color4(1, 0.5, 0, 1.0);
fireParticleSystem.color2 = new BABYLON.Color4(1, 0.8, 0, 1.0);
fireParticleSystem.colorDead = new BABYLON.Color4(0.5, 0, 0, 0.0);

// Size and lifetime
fireParticleSystem.minSize = 0.2;
fireParticleSystem.maxSize = 0.8;
fireParticleSystem.minLifeTime = 0.3;
fireParticleSystem.maxLifeTime = 1.0;

// Emission rate
fireParticleSystem.emitRate = 80;

// Direction and speed
fireParticleSystem.direction1 = new BABYLON.Vector3(-1, -1, -1);
fireParticleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);
fireParticleSystem.minEmitPower = 0.5;
fireParticleSystem.maxEmitPower = 2.0;
fireParticleSystem.updateSpeed = 0.01;

// Gravity
fireParticleSystem.gravity = new BABYLON.Vector3(0, -2, 0);

// Blending mode for fire effect
fireParticleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

fireParticleSystem.start();

// ===== Comet Trail System =====
const trailParticleSystem = new BABYLON.ParticleSystem("trail", 200, scene);
trailParticleSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
trailParticleSystem.emitter = ball;

// Trail properties
trailParticleSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
trailParticleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
trailParticleSystem.color1 = new BABYLON.Color4(0.2, 0.8, 1, 0.8);
trailParticleSystem.color2 = new BABYLON.Color4(0.5, 1, 1, 0.6);
trailParticleSystem.colorDead = new BABYLON.Color4(0, 0, 0.5, 0);

// Size and lifetime for trail
trailParticleSystem.minSize = 0.1;
trailParticleSystem.maxSize = 0.3;
trailParticleSystem.minLifeTime = 0.8;
trailParticleSystem.maxLifeTime = 1.5;

// Emission rate
trailParticleSystem.emitRate = 60;

// Direction (opposite to ball movement for trail effect)
trailParticleSystem.direction1 = new BABYLON.Vector3(-0.2, -0.2, -0.2);
trailParticleSystem.direction2 = new BABYLON.Vector3(0.2, 0.2, 0.2);
trailParticleSystem.minEmitPower = 0.2;
trailParticleSystem.maxEmitPower = 0.8;
trailParticleSystem.updateSpeed = 0.01;

// No gravity for trail
trailParticleSystem.gravity = new BABYLON.Vector3(0, 0, 0);

// Additive blending for glow effect
trailParticleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

trailParticleSystem.start();

// ===== Materials =====
const paddleMaterial = new BABYLON.StandardMaterial("paddleMaterial", scene);
paddleMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
leftPaddle.material = paddleMaterial;
rightPaddle.material = paddleMaterial;

// Enhanced ball material with cool blue glow for comet effect
const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
ballMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.9, 1); // Cool blue-white
ballMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.6, 1); // Bright blue glow
ballMaterial.specularColor = new BABYLON.Color3(0.5, 0.8, 1); // Blue specular highlights
ball.material = ballMaterial;

const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", scene);
wallMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.8);
topWall.material = wallMaterial;
bottomWall.material = wallMaterial;

const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
groundMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
groundMaterial.alpha = 1.0;
ground.material = groundMaterial;

const backWallMaterial = new BABYLON.StandardMaterial("backWallMaterial", scene);
backWallMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
backWallMaterial.alpha = 1.0;
backWall.material = backWallMaterial;

// Shadows
shadowGenerator.addShadowCaster(leftPaddle);
shadowGenerator.addShadowCaster(rightPaddle);
shadowGenerator.addShadowCaster(ball);
ground.receiveShadows = true;
backWall.receiveShadows = true;

// ===== Input Handling =====
window.addEventListener("keydown", (e) => { gameState.keys[e.code] = true; });
window.addEventListener("keyup", (e) => { gameState.keys[e.code] = false; });

// ===== Game Functions =====
function updatePaddles() {
  if (gameState.keys["KeyW"] && leftPaddle.position.y < 4.5) leftPaddle.position.y += gameState.paddleSpeed;
  if (gameState.keys["KeyS"] && leftPaddle.position.y > -4.5) leftPaddle.position.y -= gameState.paddleSpeed;
  if (gameState.keys["ArrowUp"] && rightPaddle.position.y < 4.5) rightPaddle.position.y += gameState.paddleSpeed;
  if (gameState.keys["ArrowDown"] && rightPaddle.position.y > -4.5) rightPaddle.position.y -= gameState.paddleSpeed;
}

function updateBallEffects() {
  // Update trail direction based on ball movement
  const trailDirection = new BABYLON.Vector3(-gameState.ballDirection.x, -gameState.ballDirection.y, 0);
  trailDirection.normalize();
  trailDirection.scaleInPlace(0.5);
  
  trailParticleSystem.direction1 = trailDirection.add(new BABYLON.Vector3(-0.2, -0.2, -0.2));
  trailParticleSystem.direction2 = trailDirection.add(new BABYLON.Vector3(0.2, 0.2, 0.2));
  
  // Enhance fire effect based on speed
  const speed = Math.sqrt(gameState.ballDirection.x * gameState.ballDirection.x + gameState.ballDirection.y * gameState.ballDirection.y);
  fireParticleSystem.emitRate = 80 + speed * 100;
  
  // Make ball glow brighter when moving faster
  ballMaterial.emissiveColor = new BABYLON.Color3(0.8 + speed * 0.5, 0.4 + speed * 0.3, 0);
}

function updateBall() {
  ball.position.x += gameState.ballDirection.x * gameState.ballSpeed;
  ball.position.y += gameState.ballDirection.y * gameState.ballSpeed;

  if (ball.position.y > 5.7 || ball.position.y < -5.7) gameState.ballDirection.y *= -1;

  if (ball.position.x < -9.5 && ball.position.x > -10.5 &&
      ball.position.y < leftPaddle.position.y + 1.5 &&
      ball.position.y > leftPaddle.position.y - 1.5) {
    gameState.ballDirection.x = Math.abs(gameState.ballDirection.x);
    gameState.ballDirection.y += (ball.position.y - leftPaddle.position.y) * 0.3;
  }

  if (ball.position.x > 9.5 && ball.position.x < 10.5 &&
      ball.position.y < rightPaddle.position.y + 1.5 &&
      ball.position.y > rightPaddle.position.y - 1.5) {
    gameState.ballDirection.x = -Math.abs(gameState.ballDirection.x);
    gameState.ballDirection.y += (ball.position.y - rightPaddle.position.y) * 0.3;
  }

  if (ball.position.x > 12) { gameState.leftScore++; updateScore(); resetBall(); }
  else if (ball.position.x < -12) { gameState.rightScore++; updateScore(); resetBall(); }
  
  updateBallEffects();
}

function resetBall() {
  ball.position.set(0, 0, 0);
  gameState.ballDirection.x = Math.random() > 0.5 ? 1 : -1;
  gameState.ballDirection.y = (Math.random() - 0.5) * 0.8;
  
  // Reset particle systems
  fireParticleSystem.reset();
  trailParticleSystem.reset();
}

function updateScore() {
  document.getElementById("leftScore").textContent = gameState.leftScore;
  document.getElementById("rightScore").textContent = gameState.rightScore;
}

// ===== Animate Sun (Light) =====
scene.onBeforeRenderObservable.add(() => {
  const time = performance.now() * 0.00005; // smaller = slower cycle
  const radius = 30;

  const sunX = Math.sin(time) * radius;
  const sunY = Math.cos(time) * radius * 0.5 + 10; // stays above horizon
  const sunZ = -20;

  directionalLight.position.set(sunX, sunY, sunZ);
  directionalLight.direction = new BABYLON.Vector3(-sunX, -sunY, 20).normalize();

  // Color shift (warm at sunrise/sunset, white at noon)
  const t = (Math.cos(time) + 1) / 2; // oscillates 0–1
  directionalLight.diffuse = new BABYLON.Color3(1.0, 0.6 + 0.4 * t, 0.4 + 0.6 * t);
});

// ===== Render loop =====
engine.runRenderLoop(() => {
  updatePaddles();
  updateBall();
  scene.render();
});

// Resize
window.addEventListener("resize", () => { engine.resize(); });

// Init
resetBall();
updateScore();
</script>
</body>
</html>